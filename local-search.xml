<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【Git Tutorial】一、gitignore和版本回退</title>
    <link href="/2024/04/19/20240419-gitignore/"/>
    <url>/2024/04/19/20240419-gitignore/</url>
    
    <content type="html"><![CDATA[<p>没错，这是一篇git教程，又名《一个往github上push文件，图方便把数据集放在了项目文件夹，然后发现因为文件过大而传不上去的CS人破防实录》</p><h2 id="从gitignore说起"><a href="#从gitignore说起" class="headerlink" title="从gitignore说起"></a>从gitignore说起</h2><p>什么是gitignore？顾名思义，就是让git在处理过程中忽略的文件。比如我在本地git仓库目录下放了一个大文件夹，但不希望这个文件夹被提交到远程仓库，那我就可以通过在本地仓库文件夹的根目录创建名为<code>.gitignore</code>的文本文件来解决这件事，文件名前的点表示隐藏的文件。在<code>.gitignore</code>文件中提及的文件&#x2F;目录都不会被git追踪，自然也不会被提交到远程。一个<code>.gitignore</code>的文件示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ignore compiled binaries</span><br>*.exe<br>*.dll<br>*.so<br><br><span class="hljs-comment"># Ignore log files</span><br>*.<span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># Ignore directory</span><br>logs/<br><br><span class="hljs-comment"># Ignore sensitive information</span><br>secret_key.txt<br><br><span class="hljs-comment"># Ignore IDE settings</span><br>.vscode/<br><br></code></pre></td></tr></table></figure><p>但如果你像我一样，先把大文件夹commit了，并且提交到了远程，但github远程仓库不接受大小如此之大的提交，所以本次提交被拒绝了。这时候你会发现，在<code>.gitignore</code>里添加这个大文件夹也于事无补，因为——</p><p>这个巨大的文件夹已经被加入git的追踪了。</p><p>那么怎么办呢？我现在希望这个文件夹从此以后不要被git追踪，并且希望本次push提交的操作要成功。</p><p>于是我开始查找原因。</p><h3 id="为什么gitignore的文件仍然会被git追踪"><a href="#为什么gitignore的文件仍然会被git追踪" class="headerlink" title="为什么gitignore的文件仍然会被git追踪"></a>为什么gitignore的文件仍然会被git追踪</h3><p>如果在 <code>.gitignore</code> 文件中添加了某个文件，但该文件仍然被 Git 追踪，可能有几个原因：</p><ol><li><strong>已经提交过的文件</strong>：如果该文件已经被提交到版本控制中，即使后来在 <code>.gitignore</code> 中添加了它，Git 仍然会继续追踪该文件。<code>.gitignore</code> 只对尚未被追踪的文件起作用。</li><li><strong>缓存中的文件</strong>：有时候即使将文件添加到 <code>.gitignore</code> 中，但如果该文件已经在 Git 缓存中，Git 仍然会继续追踪它。你可以通过以下步骤解决这个问题：<ul><li>首先确保在 <code>.gitignore</code> 文件中正确地指定了该文件的路径模式。</li><li>然后从 Git 缓存中删除该文件：<code>git rm --cached 文件名</code></li><li>最后提交修改：<code>git commit -m &quot;Remove &lt;file&gt; from tracking&quot;</code></li></ul></li><li><strong>全局设置的忽略规则不生效</strong>：有时候，如果在全局 Git 配置中设置了全局的忽略规则，而你在项目中的 <code>.gitignore</code> 文件中又有冲突的规则，可能会导致混淆。确保你在项目中的 <code>.gitignore</code> 文件中的规则不会被全局设置的规则覆盖。</li></ol><p>最初，我不知道我的这种情况数据集大文件夹是在缓存中还是被当作了“已经提交的文件”。所以我从回顾git的每一步开始分析（悲）。</p><h2 id="Git使用步骤回顾和问题解决"><a href="#Git使用步骤回顾和问题解决" class="headerlink" title="Git使用步骤回顾和问题解决"></a>Git使用步骤回顾和问题解决</h2><p>在使用 Git 进行版本控制时，通常会经历三个区域：</p><ol><li><strong>工作目录（Working Directory）</strong>：包含实际的项目文件。</li><li><strong>暂存区（Staging Area）</strong>：一个缓存区域，用于临时存放工作目录的改动，等待提交到 Git 仓库。又称为<strong>索引（index）</strong>，本质为一个二进制文件，存储于<code>.git</code>目录的<code>index</code>文件中。</li><li><strong>仓库（Repository）</strong>：Git 仓库保存项目的元数据和对象数据库，包括完整的项目历史记录。</li></ol><p>来回顾一下我要做什么：我本来有一个远程仓库，以及和它完全一样的本地仓库。</p><p>但我在本地写了新的代码，也就是在本地仓库修改了<strong>工作目录</strong>的内容并通过<code>git add .</code>命令将当前<strong>工作目录</strong>的所有修改提交到<strong>暂存区</strong>。然后我使用了<code>git commit</code>命令将修改从<strong>暂存区</strong>提交到<strong>本地仓库</strong>，最后我使用<code>git push</code>将本地仓库推送到远程。</p><p>如果我想取消这次提交，应该从哪个步骤着手？</p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>首先是<code>git add</code>。我去查了git的文档：<a href="https://git-scm.com/docs">https://git-scm.com/docs</a> ，其中提到<code>git add</code>命令的作用：</p><blockquote><p>Add file contents to the index</p></blockquote><p>也就是说，<code>git add</code> 的作用是，通过更新<strong>索引</strong>（index）将<strong>工作目录</strong>中的文件添加到<strong>暂存区</strong>，使得 Git 能够跟踪这些文件的变化。也就是说，此时的大文件夹已经被git追踪了，这时候再通过<code>.gitignore</code>加新东西也没用了。</p><p>合理的，那我就从git缓存（索引）里把那个多加的大文件删掉呗！于是我试图使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git -<span class="hljs-built_in">rm</span> --cached filename<br></code></pre></td></tr></table></figure><p>以把文件（夹）从git索引里移除。然后我确定我的<code>.gitignore</code>文件里有这个大文件夹的名字，并再次通过add-commit-push三步指令试图把本地仓库提交到远程，仍然失败——仍然提交了一个大文件夹。</p><h3 id="git-status-git-push"><a href="#git-status-git-push" class="headerlink" title="git status &amp; git push"></a>git status &amp; git push</h3><p>太怪了！</p><p>于是我去问了GPT，我如何查看某次git提交即将交什么，希望从查提交文件列表里发现端倪。</p><p>GPT告诉我：</p><blockquote><p>可以使用<code>git status</code> 命令来显示工作目录和暂存区的状态信息，其中会列出暂存区中被修改或添加的文件。文件列表将会出现在 “Changes to be committed” 部分下面。</p></blockquote><p>于是我使用了<code>git status</code>，而结果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">On branch main<br>Your branch is ahead of <span class="hljs-string">&#x27;origin/main&#x27;</span> by 4 commits.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br></code></pre></td></tr></table></figure><p>也就是说，我的本地分支已经领先远程分支4次提交了。（本文所涉及的仓库只有分支，分支就是整个仓库）</p><p>而git push命令的逻辑是：</p><blockquote><p><code>git push</code> 命令会将本地分支上的所有提交按顺序推送到远程仓库。远程仓库接收到这些提交后，会按照它们在本地分支上的顺序来存储和记录。</p><p>当你运行 <code>git push</code> 命令时，Git 会将本地分支上自上次推送以来新增的所有提交（即本地分支领先于远程分支的提交）推送到远程仓库。这些提交会按照它们在本地分支上的顺序被推送到远程仓库，并在远程仓库上创建一个相应的提交历史记录。</p><p>所以，如果你在本地分支上进行了多次提交，<code>git push</code> 会将这些提交依次推送到远程仓库，并在远程仓库上创建相应的提交记录，以保持提交的顺序一致。</p></blockquote><p>好极了！也就是说，因为第$x$次没提交成功，我把文件夹从索引里删掉了，紧接着创建了第$x+1$个提交。虽然第$x+1$个提交里没有那个大文件夹，但是第$x$次提交里有啊！</p><p>所以只改索引不管用啊，因为每次<code>git push</code>操作都会从第一个提交开始推送到远程，而第一个提交里包含了一个大文件夹，所以……</p><p>此时我突然明白了那句“文件已经被提交到版本控制”是什么意思。这里的“提交到版本控制”指的应该是<code>commit</code>到某个仓库（包括本地仓库），而不是我原来理解的<code>commit</code>和<code>push</code>到远程。</p><p>那现在要做的事情也很清晰了，我需要把这几次本地提交记录都删了，但保留我的源文件，也就是某种版本回退。</p><h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>首先想知道现在本地有多少版本的提交，可以通过<code>git log</code>查看。</p><p>可以看到有指针的存在。</p><p>然后我想删除提交记录，但保留工作区的文件不变（也就是说不是连同文件一起的版本回退）。这时候就可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft HEAD^(或者其他commit的HASH值)<br></code></pre></td></tr></table></figure><p>这里git reset命令的帮助文档里解释的很清晰：<a href="https://git-scm.com/docs/git-reset">https://git-scm.com/docs/git-reset</a> 。相反地，<code>--hard</code>就是直接版本回退到提交之前，并且工作目录里的文件也会相应地被修改，回退到指针指向的提交的状态。</p><p>使用soft只删除提交但不删除文件之后，重新进行add-commit-push三步，终于成功将本地修改推送到远程了，一把辛酸泪。</p><h2 id="关于Git索引和working-tree"><a href="#关于Git索引和working-tree" class="headerlink" title="关于Git索引和working tree"></a>关于Git索引和working tree</h2><p>最后，索引其实几乎就是暂存区。了解索引的工作原理对理解git的工作流程很有帮助，此处不再赘述，放几个参考文献（逃）</p><p><a href="https://git-scm.com/docs">Git官方文档</a></p><p><a href="https://geek-docs.com/git/git-questions/1174_git_what_does_the_git_index_contain_exactly.html#:~:text=Git%E7%B4%A2%E5%BC%95%E6%98%AFGit%E6%BA%90%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%B9%8B%E4%B8%80%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E4%BB%8B%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8CGit%E4%BB%93%E5%BA%93%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9A%82%E5%AD%98%E5%8C%BA%E5%9F%9F%E3%80%82,%E7%AE%80%E5%8D%95%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%AE%83%E6%98%AF%E4%B8%80%E4%B8%AA%E8%AE%B0%E5%BD%95%E4%BA%86%E8%A2%AB%E6%B7%BB%E5%8A%A0%E3%80%81%E4%BF%AE%E6%94%B9%E6%88%96%E5%88%A0%E9%99%A4%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%BF%AB%E7%85%A7%E5%92%8C%E7%8A%B6%E6%80%81%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E3%80%82">Git索引（Index）到底包含了什么|极客教程 (geek-docs.com)</a></p><p><a href="https://blog.csdn.net/zebghfv/article/details/120782767">git reset –soft命令的使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/raoxiaoya/article/details/110824019">git深入理解(一)：暂存区(Stage)，索引(index)_git index-CSDN博客</a></p><p><a href="https://www.cnblogs.com/Jing-Wang/p/10991008.html">git–一文弄懂git的工作区、索引区、本地仓库、远程仓库以及add、commit、push三个操作 - at_today - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>必先利其器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo和GithubPage的个人博客搭建教程</title>
    <link href="/2024/02/17/blog-env-tutorial/"/>
    <url>/2024/02/17/blog-env-tutorial/</url>
    
    <content type="html"><![CDATA[<p>刚搭完，趁我还记得我今天做了啥赶紧写一下教程（）</p><p>首先，什么是Hexo呢？文心一言如是说：</p><p>Hexo是<strong>一个基于Node.js的静态博客框架</strong>，具有快速、简洁且高效的特点。它拥有丰富的<strong>插件</strong>和主题，支持<strong>Markdown</strong>语法，使得编写博客文档变得方便快捷。Hexo使用<strong>Node.js</strong>进行开发，安装和部署过程简单，只需要<strong>几个npm命令</strong>即可完成。由于它是纯静态博客，不需要额外的数据库或PHP环境，<strong>仅仅需要一个Node.js环境</strong>即可运行。</p><p>这是Hexo的中文文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a>，包含了很详细的安装教程和介绍。</p><h2 id="Hexo环境配置"><a href="#Hexo环境配置" class="headerlink" title="Hexo环境配置"></a>Hexo环境配置</h2><p>正如文档中所说，配置Hexo环境首先要安装Node.js和git，此处不予赘述，详见Hexo文档。</p><p>Node.js官网：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a>。注意安装Node.js的时候Add to path即可。</p><p>装好Node.js之后就可以愉快地输入一系列npm命令了：）</p><p>建议新建一个文件夹，然后进入安装Hexo（npm好像是允许局部装包的，就装在当前文件夹下）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> myblog<br><span class="hljs-built_in">cd</span> myblog<br></code></pre></td></tr></table></figure><p>对于熟悉 npm 的进阶用户（显然不是我，我没试过），可以仅局部安装 <code>hexo</code> 包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo<br></code></pre></td></tr></table></figure><p>对于新手如我，选择按照文档，一行代码装好Hexo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><h3 id="关于npm"><a href="#关于npm" class="headerlink" title="关于npm"></a>关于npm</h3><p>npm是Node.js的包管理器（Node Package Manager），用于管理Node.js应用程序的依赖项（包），类似于Python的pip。</p><p>可以用<code>npm list</code>查看当前项目目录下安装的依赖项。我最后一共装了这些：</p><p><img src="/2024/02/17/blog-env-tutorial/image-20240217224344696.png"></p><h3 id="关于Hexo-Theme"><a href="#关于Hexo-Theme" class="headerlink" title="关于Hexo Theme"></a>关于Hexo Theme</h3><p>Theme可以理解为博客模板，可以理解为，博客网站的UI形式框架已经被模板搭好了，这让博客搭建者可以只专注于博客内容的书写本身，而不是一头扎入前端三大件的海洋（笑）</p><p>我用的主题是<strong>Fluid</strong>。</p><p>它的文档很完整，对新手很友好，并且可以根据文档，自己对网站的部分UI进行调整：<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid 用户手册 (fluid-dev.com)</a></p><h2 id="如何部署"><a href="#如何部署" class="headerlink" title="如何部署"></a>如何部署</h2><p>根据主题文档的说明和Hexo文档的说明修改配置文件config等，就能配置自己的博客啦。具体配置的过程详见<a href="https://hexo.io/zh-cn/docs/setup">建站 | Hexo</a>。</p><h3 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><h3 id="写blog"><a href="#写blog" class="headerlink" title="写blog"></a>写blog</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new [layout] &lt;title&gt;<br></code></pre></td></tr></table></figure><p><img src="/2024/02/17/blog-env-tutorial/image-20240217191647019.png"></p><p>新建的blog文件会出现在<code>source/_posts</code>文件夹下。每天都在感叹Markdown语法真是伟大的发明（笑）。</p><h3 id="Hexo-Server"><a href="#Hexo-Server" class="headerlink" title="Hexo Server"></a>Hexo Server</h3><p>Server可以建立一个本地服务器查看网页，以对博客网页进行本地调试。在博客目录下输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>这时候点击<code>http://localhost:4000/</code>可以在浏览器中查看网页。当然也可以参照Hexo文档中所提到的方法修改端口号。</p><p><img src="/2024/02/17/blog-env-tutorial/image-20240217230112238.png"></p><h3 id="部署到Github-Page"><a href="#部署到Github-Page" class="headerlink" title="部署到Github Page"></a>部署到Github Page</h3><p>首先要在Github新建一个空仓库，仓库的名称需要是：<code>username.github.io</code>，然后在仓库设置界面把pages打开。</p><p>Hexo的git一键部署还是很方便的。当然也可以参照Hexo文档进行其他的部署方式，也可以将你的github域名和自己的域名绑定，从而通过一个稳定的url访问blog。</p><h4 id="记得改URL"><a href="#记得改URL" class="headerlink" title="记得改URL"></a>记得改URL</h4><p>部署到github page的话，记得在config里改URL为噢！比如这样：</p><p><img src="/2024/02/17/blog-env-tutorial/image-20240217230817610.png"></p><blockquote><p>Set your site url here. For example, if you use GitHub Page, set url as <a href="https://username.github.io/project">https://username.github.io/project</a></p></blockquote><p>这个URL会成为网站的根目录，其他所有静态文件的url都是这个目录的子文件夹。</p><h4 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h4><p>我参考的是git一键部署，首先在博客所在文件夹安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>然后在config文件里添加deploy，如图：</p><p><img src="/2024/02/17/blog-env-tutorial/image-20240217231054160.png"></p><p>deploy的可选参数在文档中可以查到：</p><p><img src="/2024/02/17/blog-env-tutorial/image-20240217231536802.png"></p><p>最后，请在库设置（Repository Settings）中将默认分支（和github pages创建所依赖的分支）设置为<code>_config.yml</code>配置中的分支名称，比如图中是<code>gh-pages</code>。</p><h4 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h4><p>在参照文档<a href="https://hexo.io/zh-cn/docs/one-command-deployment">部署 | Hexo</a>的一键部署部分配置完之后，想把博客部署到github page，只需如下两步！</p><p>首先：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>即可访问<a href="https://username.github.io查看你的博客啦!/">https://username.github.io查看你的博客啦！</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>环境配置</tag>
      
      <tag>必先利其器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序：树洞的年轮</title>
    <link href="/2024/02/17/Hello-World-0/"/>
    <url>/2024/02/17/Hello-World-0/</url>
    
    <content type="html"><![CDATA[<p>Hello World！</p><p>你好！我是溟溯。溟溯的树洞感谢你的到来。</p><p>在信息爆炸的每一天里，孤零零的个人博客就像是汪洋中的孤岛。YOLO、VAE、Transformer、Diffusion，全新的深度网络、框架和应用层出不穷，ChatGPT、StableDiffusion和Sora似乎正在将未来推向狂飙的方向，而我的博客陷入沉寂，与世隔绝——在现实的忙碌中，溟溯的树洞年久失修。</p><p>这已然是溟溯的树洞的第三个版本：最早的树洞建立于2021年7月22日，后于2022年3月6日更换主题模板，并对网站与博客进行整理；在2024年2月17日，将博客框架从Jekyll更换到Hexo，将模板更换为如今的Fluid。在整个2023年，溟溯的树洞一言不发，没有收到来自溟溯的任何博文。</p><p>直到未来的轨道出现、匆忙的步履暂歇，我方有时间回望过去：在过去的一年里，在对未来的迷茫里，我兜兜转转，过往的记忆在逐渐变得不真切，而我试图在一切的流逝中抓住那些我曾“存在”的见证，却说不出个所以然。作为一位大四学生，我开始认真回忆我在计算机系的将近四年的日子。</p><p>或许我已走了很远，从连VSCode配个环境都吃力的编程小白到给自己搭博客网站的小白；打了（不知道学成了什么样的）数理基础，以及从零开始的C++生活，在机器学习的摸爬滚打中对着帮助文档写Python程序；写汇编代码、写过CPU、写过体系结构流水线、写过基于Yolo的流程图检测、配置过外挂文档的大语言模型、做过符号音乐序列的和弦生成；去见证过图形学、SDN的瑰丽，计算机安全和密码学的神奇，最后走上了数学和机器学习的道路。记忆的框架仍在，只是细节逐渐变得模糊，还有更多的细节已经模糊，甚至从未存在于记忆之中。它因久远失真而失去了“记录”的本能，我也可能在这样的旅途中忘记了曾经的酸甜苦辣，忘记了曾经的“感受”，忘记了来时的路。</p><p>正因如此，我需要属于我的“存在的见证”。于是，溟溯的树洞应运而生。它就像大语言模型的外挂知识库，我不必全部记得，但需要存在一种用于见证的索引。</p><p>我在日复一日的沉默中失语，表达便成为了一种亟待学习的能力。曾有人说，一首曲子只有在登台演奏后才能算是学会。与之类似，一位优秀的老师曾经向我们介绍过小黄鸭程序调试法：当你调不出bug，不妨试着对桌上的小黄鸭讲讲你这段代码背后的想法。认真而专注的讲述是如此迫在眉睫，树洞便由此出现。博客让我在叙述之时拥抱自己，首先它是写给自己的历史。它可能是我在完成项目中的点滴，可能是生活中的杂谈，可能是解题时的灵光一闪，可能是我对我的发现的概括与论证。它正见证我的足迹，唤醒我沉睡的声音，记录我曾“鲜活地存在过”，也让我在明亮的真实中走向未来。</p><p>这是溟溯的树洞，是属于“我”的历史与现在。</p><p>感谢你看到这里，也很高兴能与你同行！</p>]]></content>
    
    
    <categories>
      
      <category>漫谈</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
